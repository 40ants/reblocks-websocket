(defpackage #:weblocks.websocket
  (:use #:cl)
  (:export
   #:websocket-widget
   #:*background*
   #:in-thread))
(in-package weblocks.websocket)


(defvar *uri* "/websocket")


;; TODO: Make a hook on webserver restart to reset this flag
(defvar *route-created* nil
  "This variable will be set to true when first WebSocket widget will be initialized.")


(defun process-websocket (env)
  (log:debug "Processing websocket env")
  
  (handler-case (let ((ws (wsd:make-server env))
                      ;; Remember session to use it later in message processing
                      (session weblocks.session::*session*))

                  ;; Bind websocket server to user's session.
                  ;; This way we'll be able to send him commands
                  ;; from other pieces of the server-side code.
                  (log:debug "Storing websocket server in the session")
                  (weblocks.session:set-value :websocket ws)

                  (wsd:on :message ws
                          (lambda (message)
                            (let ((weblocks.session::*session* session))
                              (log:debug "Received websocket message" message))
                            
                            ;; (wsd:send ws (concatenate 'string
                            ;;                           "pong "
                            ;;                           message))
                            ))
    
                  (lambda (responder)
                    (declare (ignore responder))
                    (log:info "Websocket responder was called" ws)
                    (wsd:start-connection ws)))
    (error ()
      (log:error "Unable to handle websocket.")
      (list 500
            (list :content-type "plain/text")
            (list "Unable to handle websocket")))))



(defclass websocket-route (routes:route)
  ())



(defun make-websocket-route (uri)
  "Makes a route for websocket handle.

Automatically adds a prefix depending on current webapp and widget."

  (let ((route (make-instance 'websocket-route
                              :template (routes:parse-template uri))))
    (routes:connect weblocks.routes:*routes* route)))


(weblocks:defwidget websocket-widget ()
  ())


(defmethod initialize-instance ((widget websocket-widget) &rest initargs)
  (declare (ignorable initargs))

  (call-next-method)

  (unless *route-created*
    (make-websocket-route *uri*)
    (setf *route-created* t)))


(defun make-websocket-client-code ()
  (weblocks.parenscript:make-dependency*
   `(flet ((on-open ()
             (console.log "Connection was opened")
             (setf (ps:@ window websocket_connected)
                   t)
             ((ps:@ this send) "connected"))
           (on-close (event)
             (if (ps:@ event was-clean)
                 (console.log "Connection closed cleanly")
                 (console.log "Connection was interrupted"))
             (console.log (+ "Code: " (ps:@ event code)
                             " reason: " (ps:@ event reason))))
           (on-message (message)
             (console.log "Message received: " message)
             (let* ((data ((ps:@ -J-S-O-N parse)
                           (ps:@ message data)))
                    (dirty-widgets (ps:@ data widgets)))
               (update-element-for-tree (widgets-json-to-tree dirty-widgets))))
           (on-error (error)
             (console.log (+ "Error: " error)))
           (connect (url)
             (console.log "Connecting to: " url)
             (let* ((full-url (+ (if (equal window.location.protocol "http:")
                                     "ws://"
                                     "wss://")
                                 window.location.host
                                 url))
                    (socket (ps:new (-web-socket full-url))))
               (setf (ps:@ socket onopen)
                     on-open
                     (ps:@ socket onclose)
                     on-close
                     (ps:@ socket onmessage)
                     on-message
                     (ps:@ socket onerror)
                     on-error)
               socket)))
      (unless (ps:@ window websocket_connected)
        (connect ,*uri*)))))


(defvar *js-dependency* nil
  "Cache for js dependency.

We have to have a cached instance. Otherwise it will be slightly different
for each widget, because of symbols autogenerated by Parenscript.")


(defmethod weblocks.dependencies:get-dependencies ((widget websocket-widget))
  (log:warn "Returning dependencies for" widget)
  (unless *js-dependency*
    (setf *js-dependency*
          (make-websocket-client-code)))
  
  (append (list *js-dependency*)
          (call-next-method)))


(defvar *background* nil
  "This variable becomes t during background processing.")



(defmethod weblocks:mark-dirty ((widget websocket-widget) &key propagate
                                                            putp)
  (declare (ignorable putp propagate))
  (log:debug "Websocket widget marked as dirty")
  
  (if *background*
      (weblocks.dependencies:with-collected-dependencies
        (let* ((rendered-widget (weblocks:render-widget widget))
               (dom-id (alexandria:make-keyword
                        (weblocks:dom-id widget)))
               (payload (list :|widgets| (list dom-id
                                               rendered-widget)))
               (json-payload (jonathan:to-json payload))
               (ws (weblocks.session:get-value :websocket)))
          (log:debug "Created" payload json-payload)
          ;; TODO: replace wsd:send with some sort of queue
          ;;       where data will be stored in case if connect
          ;;       was interrupted.
          (if ws
              (wsd:send ws json-payload)
              (log:warn "No websocket connection"))))
      (call-next-method)))



(defmethod weblocks.routes:serve ((route websocket-route) env)
  (process-websocket env))



(defmacro in-thread ((thread-name) &body body)
  "Starts give piece of code in named thread, ensiring that weblocks.session::*session* and
weblocks.request:*request* will be bound during it's execution.

Also, it set weblocks.websocket:*backround* to true, to make mark-dirty method distinguish
between usual request processing and background activity."
  
  `(let* ((session weblocks.session::*session*)
          (request weblocks.request:*request*)
          stop-thread)

     ;; Here we need to drop this header if it exists,
     ;; to make ajax-request-p return false for subsequent calls
     ;; in the thread.
     (when (weblocks.request:request-header "X-Requested-With"
                                            :request request)
       (weblocks.request:remove-request-header "X-Requested-With"
                                               :request request))
     
     (bt:make-thread (lambda ()
                       (loop
                         while (not stop-thread)
                         do (let ((weblocks.session::*session* session)
                                  (weblocks.request:*request* request)
                                  (*background* t))
                              ,@body)))
                     :name ,thread-name)

     (weblocks.hooks:add-application-hook :stop-weblocks
         stop-counter-thread ()
       (setf stop-thread t))))


(weblocks.hooks:add-application-hook :stop-weblocks
    reset-route ()
  (weblocks.hooks:call-next-hook)
  ;; Resetting the flag to recreate a route on next start.
  (setf *route-created* nil))


(weblocks.hooks:add-application-hook :stop-weblocks
    reset-js-code-cache ()
  (weblocks.hooks:call-next-hook)
  (setf *js-dependency* nil))
